Below is a single, self-contained set of instructions you can drop into your Replit repo (e.g. in your README or as a “New Command”) to extend the existing Next.js/React + Node.js/Express + MongoDB Atlas app with a context-aware “AM” chatbot. It builds on your system prompt and adds:

1. **Context detection** (front-end vs. dashboard/back-end).
2. **Different resource recommendations** depending on where AM is invoked.
3. **Usage throttling** on public pages so non-members don’t burn through API calls.

Paste the entire block below into your project, and follow each step exactly.

---

```
You already have a Next.js/React frontend, Node.js/Express API routes, and MongoDB models for users, courses, lessons, etc. Now add a floating, context-aware conversational AI called “AM” that behaves differently depending on whether the user is on a public (front-end) page or inside the protected dashboard. Also, throttle public (non-member) usage to avoid excessive API calls.

1. SYSTEM PROMPT (for OpenAI)  
   In every call to OpenAI’s ChatCompletion endpoint, prepend this `system` message exactly:

```

You are “AM,” the brotherly best friend in a man’s pocket for The Authentic Man Project. Always lead with empathy—respond as you would to a close friend who’s having a rough day. If a user shares “I’m having a bad day,” “my wife and I aren’t getting along,” “my kids are being crazy,” etc., offer genuine encouragement, active listening, and practical perspective first.

Based on the user’s location:
• If `context = "public"`, recommend only front-end resources: blog articles, “AM Radio” podcast episodes, newsletter signup, or other free content on theamproject.com. Do NOT reference course pages, lessons, or any dashboard features.
• If `context = "dashboard"`, offer robust guidance tied to the user’s curriculum: suggest specific lessons, reflection prompts, or next steps inside the dashboard. Use internal course names, lesson IDs, and journal prompts as appropriate.

Always address the user by their first name (never a persona tag). Keep tone supportive, candid, and conversational—2–3 short paragraphs max. Never mention internal API details or system errors; if you don’t know something, admit it and offer an alternative or resource. Emphasize strength, integrity, discipline, and purpose—putting brotherly empathy first.

````

2. DATA MODEL FOR CHAT  
In `models/ChatMessage.js`, add:

```js
import mongoose from 'mongoose';

const chatMessageSchema = new mongoose.Schema({
  userId: { type: mongoose.Schema.Types.ObjectId, ref: 'User', required: true },
  context: { type: String, enum: ['public','dashboard'], required: true },
  role: { type: String, enum: ['user','am'], required: true },
  text: { type: String, required: true },
  timestamp: { type: Date, default: Date.now }
});

export default mongoose.models.ChatMessage || mongoose.model('ChatMessage', chatMessageSchema);
````

3. FRONTEND COMPONENT (React + Tailwind)
   Create `components/AMChat.js` with these responsibilities:

   ```jsx
   import { useState, useEffect, useRef } from 'react';
   import axios from 'axios';
   import jwtDecode from 'jwt-decode';
   import Cookie from 'js-cookie';

   export default function AMChat() {
     const [open, setOpen] = useState(false);
     const [loading, setLoading] = useState(false);
     const [input, setInput] = useState('');
     const [messages, setMessages] = useState([]);
     const [context, setContext] = useState('public'); // default to public
     const scrollRef = useRef();

     // 1. On mount, determine context by URL and fetch history
     useEffect(() => {
       const pathname = window.location.pathname;
       if (pathname.startsWith('/dashboard') || pathname.startsWith('/courses') || pathname.startsWith('/community') || pathname.startsWith('/pod') || pathname.startsWith('/journal')) {
         setContext('dashboard');
       } else {
         setContext('public');
       }
       fetchHistory();
     }, []);

     const fetchHistory = async () => {
       try {
         const res = await axios.get('/api/ai/chat/history', { params: { context } });
         setMessages(res.data.messages);
         scrollToBottom();
       } catch (err) {
         // if 401 or other, we simply start empty
         console.error(err);
       }
     };

     const sendMessage = async () => {
       if (!input.trim()) return;
       const userToken = Cookie.get('jwt');
       if (context === 'public' && !userToken) {
         // Throttle public usage: allow up to 3 messages per hour for guests
         const now = Date.now();
         const log = JSON.parse(localStorage.getItem('amPublicLog') || '[]');
         const windowStart = now - 60 * 60 * 1000; // 1 hour ago
         const recent = log.filter(ts => ts > windowStart);
         if (recent.length >= 3) {
           setMessages(prev => [
             ...prev,
             { role: 'am', text: 'Hey there—free usage is limited to 3 messages per hour. Consider signing up to chat more often.', timestamp: new Date() }
           ]);
           return;
         }
         recent.push(now);
         localStorage.setItem('amPublicLog', JSON.stringify(recent));
       }

       const userMessage = { role: 'user', text: input, timestamp: new Date() };
       setMessages(prev => [...prev, userMessage]);
       setLoading(true);
       setInput('');

       try {
         const res = await axios.post('/api/ai/chat', { text: input, context });
         setMessages(prev => [...prev, { role: 'am', text: res.data.reply, timestamp: new Date() }]);
       } catch (err) {
         setMessages(prev => [
           ...prev,
           { role: 'am', text: 'Sorry—something went wrong. Try again later.', timestamp: new Date() }
         ]);
       } finally {
         setLoading(false);
         scrollToBottom();
       }
     };

     const scrollToBottom = () => {
       if (scrollRef.current) {
         scrollRef.current.scrollTop = scrollRef.current.scrollHeight;
       }
     };

     return (
       <>
         {/* Chat Icon */}
         <button
           onClick={() => setOpen(!open)}
           className="
             fixed bottom-4 right-4 z-50
             bg-[#7C4A32] ring-2 ring-[#E4B768] hover:ring-[#F0CD80]
             text-white rounded p-3 shadow-lg
           "
         >
           {open ? '×' : 'AM'}
         </button>

         {/* Chat Panel */}
         {open && (
           <div
             className="
               fixed bottom-4 right-4 z-50 flex flex-col
               w-[95vw] sm:w-96 h-[80vh] sm:h-[60vh]
               bg-white rounded shadow-lg
             "
           >
             {/* Header */}
             <div className="flex items-center justify-between bg-[#7C4A32] px-4 py-2 rounded-t">
               <h2 className="text-[#E4B768] font-semibold">Chat with AM</h2>
               <button onClick={() => setOpen(false)} className="text-white hover:text-[#F5EDE1]">×</button>
             </div>

             {/* Messages */}
             <div ref={scrollRef} className="flex-1 overflow-y-auto p-4 space-y-3 bg-[#F5EDE1]">
               {messages.map((msg, idx) => (
                 <div key={idx} className="flex flex-col">
                   {msg.role === 'user' ? (
                     <div className="self-end bg-[#7C4A32] text-white rounded px-3 py-2 max-w-[80%]">
                       {msg.text}
                     </div>
                   ) : (
                     <div className="self-start bg-[#F5EDE1] text-[#333333] rounded px-3 py-2 max-w-[80%]">
                       {msg.text}
                     </div>
                   )}
                   <span className={`text-xs text-[#333333] mt-1 ${msg.role === 'user' ? 'self-end' : 'self-start'}`}>
                     {new Date(msg.timestamp).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' })}
                   </span>
                 </div>
               ))}
             </div>

             {/* Input */}
             <div className="flex items-center px-4 py-2 border-t border-[#333333] bg-white">
               <input
                 type="text"
                 value={input}
                 onChange={e => setInput(e.target.value)}
                 onKeyDown={e => { if (e.key === 'Enter') sendMessage(); }}
                 placeholder="Type your message…"
                 className="
                   flex-grow border border-[#333333] rounded px-3 py-2
                   focus:outline-none focus:ring-2 focus:ring-[#E4B768]
                 "
                 disabled={loading}
               />
               <button
                 onClick={sendMessage}
                 disabled={loading || !input.trim()}
                 className="
                   ml-2
                   bg-[#7C4A32] text-white font-semibold rounded px-4 py-2
                   hover:bg-[#8A553F] disabled:bg-[#333333] disabled:cursor-not-allowed
                 "
               >
                 {loading
                   ? <div className="animate-spin h-5 w-5 border-2 border-[#7C4A32] border-t-transparent rounded-full"></div>
                   : 'Send'}
               </button>
             </div>
           </div>
         )}
       </>
     );
   }
   ```

   • In `pages/_app.js`, wrap your application so that `<AMChat />` only renders when a valid JWT is present. For example:

   ```js
   import AMChat from '../components/AMChat';
   import { useEffect, useState } from 'react';
   import Cookie from 'js-cookie';

   function MyApp({ Component, pageProps }) {
     const [isAuthenticated, setIsAuthenticated] = useState(false);

     useEffect(() => {
       const token = Cookie.get('jwt');
       if (token) setIsAuthenticated(true);
     }, []);

     return (
       <>
         <Component {...pageProps} />
         {isAuthenticated && <AMChat />}
       </>
     );
   }

   export default MyApp;
   ```

4. BACKEND ROUTES (Express + OpenAI)
   Create two new API files under `pages/api/ai/chat/`:

   1. **`pages/api/ai/chat/history.js`**

      ```js
      import dbConnect from '../../../../lib/dbConnect';
      import ChatMessage from '../../../../models/ChatMessage';
      import jwt from 'jsonwebtoken';

      export default async function handler(req, res) {
        if (req.method !== 'GET') return res.status(405).end();
        try {
          await dbConnect();
          const token = req.cookies.jwt;
          if (!token) return res.status(401).json({ error: 'Not authenticated' });
          const { userId } = jwt.verify(token, process.env.JWT_SECRET);
          const { context } = req.query; // "public" or "dashboard"
          const messages = await ChatMessage.find({ userId, context })
            .sort({ timestamp: 1 })
            .limit(20);
          return res.status(200).json({ messages });
        } catch (err) {
          console.error(err);
          return res.status(500).json({ error: 'Server error' });
        }
      }
      ```

   2. **`pages/api/ai/chat/index.js`**

      ```js
      import dbConnect from '../../../../lib/dbConnect';
      import ChatMessage from '../../../../models/ChatMessage';
      import jwt from 'jsonwebtoken';
      import { Configuration, OpenAIApi } from 'openai';

      export default async function handler(req, res) {
        if (req.method !== 'POST') return res.status(405).end();
        try {
          await dbConnect();
          const token = req.cookies.jwt;
          // If no token, allow public context but skip userId (use guest limit logic on frontend)
          let userId = null;
          if (token) {
            const decoded = jwt.verify(token, process.env.JWT_SECRET);
            userId = decoded.userId;
          }
          const { text, context } = req.body; // context: "public" or "dashboard"
          if (!text || typeof text !== 'string') {
            return res.status(400).json({ error: 'Invalid input' });
          }

          // 1. Save user message (userId may be null for guests, but skip saving if null)
          if (userId) {
            await ChatMessage.create({ userId, context, role: 'user', text });
          }

          // 2. Fetch last 10 messages of same context for that user (if logged in)
          let messagesForPrompt = [];
          if (userId) {
            const recent = await ChatMessage.find({ userId, context })
              .sort({ timestamp: -1 })
              .limit(10);
            messagesForPrompt = recent
              .map(msg => ({
                role: msg.role === 'am' ? 'assistant' : 'user',
                content: msg.text
              }))
              .reverse();
          }

          // 3. Build system prompt + context instructions
          const systemPrompt = {
            role: 'system',
            content: `
      ```

You are “AM,” the brotherly best friend in a man’s pocket for The Authentic Man Project. Always lead with empathy—respond as you would to a close friend who’s having a rough day. If a user shares “I’m having a bad day,” “my wife and I aren’t getting along,” “my kids are driving me nuts,” etc., offer genuine encouragement, active listening, and practical perspective first.

Based on the user’s location:
• If context = "public", recommend only front-end resources: blog articles, “AM Radio” podcast, newsletter signup, or other free content. Do NOT reference course pages or any dashboard features.
• If context = "dashboard", offer robust guidance tied to the user’s curriculum: suggest specific lessons, reflection prompts, or next steps inside the dashboard. Use internal course names, lesson IDs, and journal prompts as appropriate.

Always address the user by their first name (never by a persona tag). Keep tone supportive, candid, and conversational—2–3 short paragraphs max. Never reveal API details or system errors; if you don’t know something, admit it plainly and offer an alternative or resource. Emphasize strength, integrity, discipline, and purpose—putting brotherly empathy first.\`
};

````
      // 4. Call OpenAI
      const openai = new OpenAIApi(
        new Configuration({ apiKey: process.env.OPENAI_API_KEY })
      );

      const messagesPayload = [
        systemPrompt,
        ...messagesForPrompt,
        { role: 'user', content: text }
      ];

      const completion = await openai.createChatCompletion({
        model: 'gpt-4',
        messages: messagesPayload,
        temperature: 0.7,
        max_tokens: 250
      });

      const amReply = completion.data.choices[0].message.content.trim();

      // 5. Save AM’s reply (if userId exists)
      if (userId) {
        await ChatMessage.create({ userId, context, role: 'am', text: amReply });
      }

      // 6. Return AM’s reply
      return res.status(200).json({ reply: amReply });
    } catch (err) {
      console.error(err);
      return res.status(500).json({ error: 'OpenAI or server error' });
    }
  }
  ```
````

5\. USAGE THROTTLING (PUBLIC)
• In the frontend (`AMChat.js`), we already limited guests to 3 messages per hour using `localStorage` and a timestamp log.
• If you need a server-side throttle, create a simple key/value in Redis or Mongo that tracks guest IPv4 or a temporary “publicUser” ID—but for MVP, the `localStorage` approach is acceptable.

6. TEST & VERIFY

   1. Run `npm install openai axios js-cookie jwt-decode` (if not already installed).

   2. Start dev server: `npm run dev`.

   3. **Public pages** (`/`, `/blog`, etc.):

      * No login → you see the “AM” bubble.
      * Click it, send up to 3 messages in an hour. Ask “I’m having a bad day” → you get empathetic, public-only recommendations.
      * On message #4, AM says “Free usage is limited to 3 messages per hour. Consider signing up to chat more often.”
      * Ask “What should I read on the blog?” → AM should recommend specific blog article titles, link to `/blog/[slug]`, or mention “AM Radio,” “newsletter signup,” etc.

   4. **Protected pages** (`/dashboard`, `/courses/...`, `/pod`, `/journal`, `/community`):

      * Log in as a user. You see the “AM” bubble.
      * Click it and ask “What’s my next lesson?” or “I’m stuck on my leadership module” → AM should respond with context-aware advice referencing actual lesson names, IDs, or routes (e.g., “JC, head over to your Leadership Basics lesson on `/courses/leadership/lesson-2`…”).
      * Ask “Today I’m overwhelmed by work” → AM responds as a brother first, then gently ties in a relevant lesson or journaling prompt.

   5. Inspect MongoDB Atlas “ChatMessage” collection:

      * Confirm documents have correct `context`, `userId`, `role`, `text`, and timestamps.

7. ADDITIONAL NOTES
   • **Environment Variables**: Ensure `process.env.OPENAI_API_KEY` and `process.env.JWT_SECRET` are set.
   • **No New CSS Files**: Use only existing Tailwind config—colors must match your brand palette exactly:

   * Primary Brand Brown: `#7C4A32`
   * Charcoal: `#333333`
   * Gold: `#E4B768`
   * Warm Cream: `#F5EDE1`
   * White: `#FFFFFF`
   * Black: `#000000`

   • **Message Length**: Keep AM replies under \~250 tokens so responses are snappy.
   • **First-Name Personalization**: In the frontend, decode the JWT (`jwt-decode`) to grab the user’s `fullName.split(' ')[0]` and pass it as a variable if you want to add a personalized greeting, e.g. “Hey Jake, I hear you…”—or let AM ask for their name on first run.

**Result**: A context-aware, throttled “Chat with AM” bubble that guides guests to public resources and logged-in users to internal curriculum—always in a brotherly, empathetic tone. Paste the block above into your Replit project or share it with your developer, and “AM” will light up across your entire stack exactly as specified.

```
```
