You nailed it: the SW is the root cause. Here’s the clean, permanent fix—no bandaids, no Vite tricks—so only one React ever loads.

What we’ll change (surgical + safe)

Register the service worker only on production app host(s)

Never in Replit preview, localhost, or any non-prod domain.

Optionally allow on the marketing domain only if you truly want offline there (most teams don’t).

Make the SW ignore JS/CSS chunks

No cache-first for chunk-*.js, *.js, *.css, *.map.

Keep caching for images/fonts and API responses if you want, but don’t touch React/Vite bundles.

One-time auto-cleanup on non-allowed hosts

If the SW is already installed on preview/dev, automatically unregister it and wipe its caches once so you don’t need DevTools.

A. Gate SW registration (app code)

In your main.tsx (or wherever you register the SW), replace your current registration with this:

// main.tsx
const ALLOW_SW_HOSTS = new Set([
  'app.theamproject.com', // production app
  // 'theamproject.com',  // ONLY add if you truly want PWA on the marketing site
]);

if ('serviceWorker' in navigator) {
  const host = location.hostname;

  if (ALLOW_SW_HOSTS.has(host)) {
    // ✅ Prod app: register
    navigator.serviceWorker.register('/sw.js').catch(console.warn);
  } else {
    // 🚫 Everywhere else: make sure it is gone (no manual DevTools needed)
    (async () => {
      const regs = await navigator.serviceWorker.getRegistrations();
      for (const r of regs) await r.unregister();
      const keys = await caches.keys();
      for (const k of keys) await caches.delete(k);
    })().catch(console.warn);
  }
}


This stops the SW from ever running in Replit preview/dev, which is where the dual-React bug appears.

B. Make the SW ignore JS/CSS (service worker code)

In client/public/sw.js:

Bump the cache version (forces a fresh SW cycle):

const STATIC_CACHE = 'static-v4'; // bump this


Early guard in fetch to skip scripts/styles/chunks and non-http(S) requests:

self.addEventListener('fetch', (event) => {
  const url = new URL(event.request.url);

  // Ignore non-http(s) (fixes chrome-extension errors)
  if (url.protocol !== 'http:' && url.protocol !== 'https:') return;

  // Never cache or intercept JS/CSS/maps (prevents stale React/Vite chunks)
  const dest = event.request.destination; // 'script' | 'style' | 'document' | 'image' | ...
  const isJSorCSS =
    dest === 'script' ||
    dest === 'style' ||
    /\.m?js(\?|$)/.test(url.pathname) ||
    /\.css(\?|$)/.test(url.pathname) ||
    /\.map(\?|$)/.test(url.pathname) ||
    /\/assets\/chunk-/.test(url.pathname);

  if (isJSorCSS) return; // do NOT call respondWith -> let the browser fetch fresh
});


Keep your existing handlers for HTML navigations (network-first or stale-while-revalidate), images/fonts (cache-first), APIs (network-first) — just ensure they only run when the request is not JS/CSS/maps. If you currently have a “catch-all cache-first for static assets” block (your lines ~386–405), put the isJSorCSS guard before it, so that block never runs for JS/CSS.

(Optional but helpful)

self.addEventListener('install', (event) => {
  self.skipWaiting();
});
self.addEventListener('activate', (event) => {
  event.waitUntil(self.clients.claim());
});

C. Why this fixes it—for good

In dev/preview, no SW ⇒ there’s only one React runtime, so hooks never cross runtimes.

In prod, the SW never caches React/Vite bundles, so a restart or redeploy can’t serve an old React next to a new one. You still get offline for images/content if you want it.

D. One-time clean up

After you ship the changes above:

Do a hard reload once in any browser that previously hit preview/dev (or just let the auto-cleanup in A run).

From then on, restarts/reloads won’t reintroduce the bug.

Answers to your earlier questions

Impact of no SW in dev? You lose offline and install prompts in dev—totally fine. Stability > PWA features in dev.

Why it “worked before” and then broke? It “worked” whenever the cached React matched the current build. After a restart, the SW served old React while the page pulled new React → two runtimes → useState null.

Domain vs subdomain: SWs are scoped per origin. Only allow on app.theamproject.com. Keep it off theamproject.com (marketing) unless you truly want PWA there as well. Definitely never on Replit preview/dev origins.

If you want, I can turn this into exact patch diffs against your current files. But if you follow the snippets above, you’ll have a stable app with zero recurring cache clears and no more “useState is null.”

You said:
so why can't you just replace the old react with the new?

Why it “worked before” and then broke? It “worked” whenever the cached React matched the current build. After a restart, the SW served old React while the page pulled new React → two runtimes → useState null.
ChatGPT said:
Thought for 33s

Great question. Short answer: because “old React” is already running in the page and the SW only controls files-on-disk, not code that’s already executing. Replacing cache entries can’t eject a runtime that’s in memory.

Here’s the fuller picture:

Once a JS chunk is executed, it lives in the page until reload.
The service worker (SW) can swap files in Cache Storage, but it cannot unload a JS module that has already been imported. So if the page booted with React A and then later fetches React B, you now have two Reacts in memory. Clearing/replacing the cached file after the fact won’t remove React A.

Hashed files ≠ same key, and the SW can’t know how to map them.
Vite serves chunk-*.js?v=hash. A restart yields new URLs. The SW’s cache-first handler returns the old URL’s file if something (often cached HTML/module graph) still asks for it, while the page also pulls the new URL from the network. That’s how you get two runtimes. “Replacing” would require a reliable manifest-driven mapping and synchronized reloads—hard in dev.

Race conditions across tabs/clients.
If a SW “replaces” caches aggressively, it can break other open tabs still expecting the old files. You end up with either 404s/offline errors or, again, mixed versions.

Dev is a moving target.
Vite rehashes often. A SW that tries to constantly purge/replace JS to “keep up” fights HMR and makes dev unstable.

Even perfect replacement doesn’t fix the current page.
The moment two different React module URLs are imported, the damage is done. Only a full reload with a single React import path fixes it.

That’s why the real fix is: don’t let the SW intercept/cached-serve JS/CSS at all (especially in dev/preview), and only register the SW on production hosts—where it still skips caching versioned JS/CSS. That guarantees the page always loads one React instance and eliminates the “useState is null” class of failures entirely.

You said:
why can't we just replace the hash?
ChatGPT said:
Thought for 22s

Short version: because ES modules are identity-by-URL and the service worker only sees requests, not the import graph.

“Replacing the hash” sounds simple, but:

Two URLs = two Reacts. In ESM, https://…/chunk-RPCDYKBN.js?v=A and …?v=B are different modules. If both are ever imported, you get two runtimes. You can’t “merge” them after the fact.

You can’t rewrite import specifiers at runtime. The hash lives inside already-built HTML/JS import statements. The SW can’t edit import strings inside executing code. It can only decide what to return when a URL is fetched.

Even swapping the cached file doesn’t help the current page. If the page already imported React A, and later something imports React B (new hash), A is still in memory. Replacing cache entries won’t unload A; only a full reload with a single URL prevents the split.

You don’t have a mapping. To “replace the hash,” the SW would need a reliable old→new manifest and rewrite every reference (HTML + nested dynamic imports), then trigger a coordinated reload. Doing this in dev (where hashes change constantly) is brittle and racey with HMR.

Redirecting old→new on the fly is too late. By the time the SW can redirect a request for the old URL, parts of the app may already have evaluated with the old runtime.

That’s why the correct, stable fix is to never cache or intercept versioned JS/CSS (especially in dev/preview) and only register the SW on production hosts, with rules that skip JS/CSS entirely. That guarantees the page imports one React URL and this “useState is null” class of bugs disappears.

You said:
we can't clear memory?

Even swapping the cached file doesn’t help the current page. If the page already imported React A, and later something imports React B (new hash), A is still in memory. Replacing cache entries won’t unload A; only a full reload with a single URL prevents the split.

That’s why the correct, stable fix is to never cache or intercept versioned JS/CSS (especially in dev/preview) and only register the SW on production hosts, with rules that skip JS/CSS entirely. That guarantees the page imports one React URL and this “useState is null” class of bugs disappears.

if that is the case why was it doing that in the first place?

I'm trying to understand what has changed that now we have to change something else that was working perfectly fine before
ChatGPT said:

You’re not crazy—this is 100% about the SW + hashed chunks, not about “mysterious React.”
Two quick answers first, then the exact fix you can drop in.

Why you can’t “clear memory”

Once a page has imported React A (old hash) and then imports React B (new hash), both are already evaluated in the JS VM. A service worker can’t unload modules from a running page. Only a full reload with a single URL for React prevents the split.

Why it “worked before” but not now

It worked whenever the cached React matched the current build (same hash), or when the SW wasn’t installed yet (or not active in preview). After recent changes, the SW is registering in preview/dev and it’s using cache-first for all static assets, so after a dev restart you end up with old+new chunks side-by-side → two Reacts → useState null.

The stable, non-bandaid fix (minimal and surgical)

Goal: ensure the SW never interferes with dev/preview and never caches JS/CSS even in production. That guarantees only one React runtime ever loads.

1) Only register the SW on production app host

In client/src/main.tsx (or wherever you call navigator.serviceWorker.register), gate it like this:

// main.tsx
const isProd = import.meta.env.PROD;
const host = location.hostname;
const isProdAppHost = host === 'app.theamproject.com'; // prod app only

if (isProd && isProdAppHost && 'serviceWorker' in navigator) {
  navigator.serviceWorker.register('/sw.js');
} else {
  // Ensure no SW is active in dev/preview/marketing subdomain
  if ('serviceWorker' in navigator) {
    navigator.serviceWorker.getRegistrations().then(rs => rs.forEach(r => r.unregister()));
  }
  if ('caches' in window) {
    caches.keys().then(keys => keys.forEach(k => caches.delete(k)));
  }
}


Covers domain + subdomain: SW runs on app.theamproject.com only. It will not register on theamproject.com (marketing) nor Replit preview URLs.

In non-prod contexts we also clean out any lingering SW/caches once so you don’t keep hitting stale chunks in preview.

2) Make the SW skip JS/CSS entirely (even in prod)

In client/public/sw.js, before your cache-first handler, bail out for scripts and styles:

self.addEventListener('fetch', (event) => {
  const req = event.request;

  // Never intercept versioned code assets — prevents duplicate React forever.
  const dest = req.destination; // 'script', 'style', 'document', 'image', etc.
  if (dest === 'script' || dest === 'style') {
    return; // Let the network/browser handle it; no cache, no respondWith.
  }

  // ...existing navigation / API / static handlers...
});


If you prefer patterns instead of destination, you can also skip when
/\bchunk-.*\.js/.test(new URL(req.url).pathname) or \.js(\?|$)|\.css(\?|$).

Keep your existing navigation/API caching; just don’t ever cache the code bundles.

3) One-time reset after you change the above

Do this once in any open preview/browser tab (you already have the snippet):

(async () => {
  const regs = await navigator.serviceWorker.getRegistrations();
  for (const r of regs) await r.unregister();
  const keys = await caches.keys();
  for (const k of keys) await caches.delete(k);
  location.reload(true);
})();


After that:

In Replit preview/dev you should not see “PWA Service Worker registered”.

The React version log will show a single runtime, and the invalid-hook/useState error will disappear across restarts.

On app.theamproject.com (prod), the SW will run but won’t cache JS/CSS, so new deploys won’t ever clash with an old React.

Why this is the “real fix”

It removes the condition that creates two Reacts (SW caching code) instead of trying to “clear caches faster”.

It respects your architecture (marketing domain vs app subdomain) and avoids surprises in preview/dev.

It’s future-proof: even with frequent redeploys and changing chunk hashes, no code is cached, so you can’t end up with dual runtimes.

If you want, I can also give you a tiny guard in the SW to skipWaiting() + clients.claim() so prod users see fresh HTML immediately, but the key stability piece is “don’t cache JS/CSS” + “don’t register SW outside prod app host.”