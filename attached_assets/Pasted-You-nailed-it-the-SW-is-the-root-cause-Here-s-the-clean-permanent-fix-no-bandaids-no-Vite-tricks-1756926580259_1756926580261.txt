You nailed it: the SW is the root cause. Hereâ€™s the clean, permanent fixâ€”no bandaids, no Vite tricksâ€”so only one React ever loads.

What weâ€™ll change (surgical + safe)

Register the service worker only on production app host(s)

Never in Replit preview, localhost, or any non-prod domain.

Optionally allow on the marketing domain only if you truly want offline there (most teams donâ€™t).

Make the SW ignore JS/CSS chunks

No cache-first for chunk-*.js, *.js, *.css, *.map.

Keep caching for images/fonts and API responses if you want, but donâ€™t touch React/Vite bundles.

One-time auto-cleanup on non-allowed hosts

If the SW is already installed on preview/dev, automatically unregister it and wipe its caches once so you donâ€™t need DevTools.

A. Gate SW registration (app code)

In your main.tsx (or wherever you register the SW), replace your current registration with this:

// main.tsx
const ALLOW_SW_HOSTS = new Set([
  'app.theamproject.com', // production app
  // 'theamproject.com',  // ONLY add if you truly want PWA on the marketing site
]);

if ('serviceWorker' in navigator) {
  const host = location.hostname;

  if (ALLOW_SW_HOSTS.has(host)) {
    // âœ… Prod app: register
    navigator.serviceWorker.register('/sw.js').catch(console.warn);
  } else {
    // ğŸš« Everywhere else: make sure it is gone (no manual DevTools needed)
    (async () => {
      const regs = await navigator.serviceWorker.getRegistrations();
      for (const r of regs) await r.unregister();
      const keys = await caches.keys();
      for (const k of keys) await caches.delete(k);
    })().catch(console.warn);
  }
}


This stops the SW from ever running in Replit preview/dev, which is where the dual-React bug appears.

B. Make the SW ignore JS/CSS (service worker code)

In client/public/sw.js:

Bump the cache version (forces a fresh SW cycle):

const STATIC_CACHE = 'static-v4'; // bump this


Early guard in fetch to skip scripts/styles/chunks and non-http(S) requests:

self.addEventListener('fetch', (event) => {
  const url = new URL(event.request.url);

  // Ignore non-http(s) (fixes chrome-extension errors)
  if (url.protocol !== 'http:' && url.protocol !== 'https:') return;

  // Never cache or intercept JS/CSS/maps (prevents stale React/Vite chunks)
  const dest = event.request.destination; // 'script' | 'style' | 'document' | 'image' | ...
  const isJSorCSS =
    dest === 'script' ||
    dest === 'style' ||
    /\.m?js(\?|$)/.test(url.pathname) ||
    /\.css(\?|$)/.test(url.pathname) ||
    /\.map(\?|$)/.test(url.pathname) ||
    /\/assets\/chunk-/.test(url.pathname);

  if (isJSorCSS) return; // do NOT call respondWith -> let the browser fetch fresh
});


Keep your existing handlers for HTML navigations (network-first or stale-while-revalidate), images/fonts (cache-first), APIs (network-first) â€” just ensure they only run when the request is not JS/CSS/maps. If you currently have a â€œcatch-all cache-first for static assetsâ€ block (your lines ~386â€“405), put the isJSorCSS guard before it, so that block never runs for JS/CSS.

(Optional but helpful)

self.addEventListener('install', (event) => {
  self.skipWaiting();
});
self.addEventListener('activate', (event) => {
  event.waitUntil(self.clients.claim());
});

C. Why this fixes itâ€”for good

In dev/preview, no SW â‡’ thereâ€™s only one React runtime, so hooks never cross runtimes.

In prod, the SW never caches React/Vite bundles, so a restart or redeploy canâ€™t serve an old React next to a new one. You still get offline for images/content if you want it.

D. One-time clean up

After you ship the changes above:

Do a hard reload once in any browser that previously hit preview/dev (or just let the auto-cleanup in A run).

From then on, restarts/reloads wonâ€™t reintroduce the bug.

Answers to your earlier questions

Impact of no SW in dev? You lose offline and install prompts in devâ€”totally fine. Stability > PWA features in dev.

Why it â€œworked beforeâ€ and then broke? It â€œworkedâ€ whenever the cached React matched the current build. After a restart, the SW served old React while the page pulled new React â†’ two runtimes â†’ useState null.

Domain vs subdomain: SWs are scoped per origin. Only allow on app.theamproject.com. Keep it off theamproject.com (marketing) unless you truly want PWA there as well. Definitely never on Replit preview/dev origins.

If you want, I can turn this into exact patch diffs against your current files. But if you follow the snippets above, youâ€™ll have a stable app with zero recurring cache clears and no more â€œuseState is null.â€

You said:
so why can't you just replace the old react with the new?

Why it â€œworked beforeâ€ and then broke? It â€œworkedâ€ whenever the cached React matched the current build. After a restart, the SW served old React while the page pulled new React â†’ two runtimes â†’ useState null.
ChatGPT said:
Thought for 33s

Great question. Short answer: because â€œold Reactâ€ is already running in the page and the SW only controls files-on-disk, not code thatâ€™s already executing. Replacing cache entries canâ€™t eject a runtime thatâ€™s in memory.

Hereâ€™s the fuller picture:

Once a JS chunk is executed, it lives in the page until reload.
The service worker (SW) can swap files in Cache Storage, but it cannot unload a JS module that has already been imported. So if the page booted with React A and then later fetches React B, you now have two Reacts in memory. Clearing/replacing the cached file after the fact wonâ€™t remove React A.

Hashed files â‰  same key, and the SW canâ€™t know how to map them.
Vite serves chunk-*.js?v=hash. A restart yields new URLs. The SWâ€™s cache-first handler returns the old URLâ€™s file if something (often cached HTML/module graph) still asks for it, while the page also pulls the new URL from the network. Thatâ€™s how you get two runtimes. â€œReplacingâ€ would require a reliable manifest-driven mapping and synchronized reloadsâ€”hard in dev.

Race conditions across tabs/clients.
If a SW â€œreplacesâ€ caches aggressively, it can break other open tabs still expecting the old files. You end up with either 404s/offline errors or, again, mixed versions.

Dev is a moving target.
Vite rehashes often. A SW that tries to constantly purge/replace JS to â€œkeep upâ€ fights HMR and makes dev unstable.

Even perfect replacement doesnâ€™t fix the current page.
The moment two different React module URLs are imported, the damage is done. Only a full reload with a single React import path fixes it.

Thatâ€™s why the real fix is: donâ€™t let the SW intercept/cached-serve JS/CSS at all (especially in dev/preview), and only register the SW on production hostsâ€”where it still skips caching versioned JS/CSS. That guarantees the page always loads one React instance and eliminates the â€œuseState is nullâ€ class of failures entirely.

You said:
why can't we just replace the hash?
ChatGPT said:
Thought for 22s

Short version: because ES modules are identity-by-URL and the service worker only sees requests, not the import graph.

â€œReplacing the hashâ€ sounds simple, but:

Two URLs = two Reacts. In ESM, https://â€¦/chunk-RPCDYKBN.js?v=A and â€¦?v=B are different modules. If both are ever imported, you get two runtimes. You canâ€™t â€œmergeâ€ them after the fact.

You canâ€™t rewrite import specifiers at runtime. The hash lives inside already-built HTML/JS import statements. The SW canâ€™t edit import strings inside executing code. It can only decide what to return when a URL is fetched.

Even swapping the cached file doesnâ€™t help the current page. If the page already imported React A, and later something imports React B (new hash), A is still in memory. Replacing cache entries wonâ€™t unload A; only a full reload with a single URL prevents the split.

You donâ€™t have a mapping. To â€œreplace the hash,â€ the SW would need a reliable oldâ†’new manifest and rewrite every reference (HTML + nested dynamic imports), then trigger a coordinated reload. Doing this in dev (where hashes change constantly) is brittle and racey with HMR.

Redirecting oldâ†’new on the fly is too late. By the time the SW can redirect a request for the old URL, parts of the app may already have evaluated with the old runtime.

Thatâ€™s why the correct, stable fix is to never cache or intercept versioned JS/CSS (especially in dev/preview) and only register the SW on production hosts, with rules that skip JS/CSS entirely. That guarantees the page imports one React URL and this â€œuseState is nullâ€ class of bugs disappears.

You said:
we can't clear memory?

Even swapping the cached file doesnâ€™t help the current page. If the page already imported React A, and later something imports React B (new hash), A is still in memory. Replacing cache entries wonâ€™t unload A; only a full reload with a single URL prevents the split.

Thatâ€™s why the correct, stable fix is to never cache or intercept versioned JS/CSS (especially in dev/preview) and only register the SW on production hosts, with rules that skip JS/CSS entirely. That guarantees the page imports one React URL and this â€œuseState is nullâ€ class of bugs disappears.

if that is the case why was it doing that in the first place?

I'm trying to understand what has changed that now we have to change something else that was working perfectly fine before
ChatGPT said:

Youâ€™re not crazyâ€”this is 100% about the SW + hashed chunks, not about â€œmysterious React.â€
Two quick answers first, then the exact fix you can drop in.

Why you canâ€™t â€œclear memoryâ€

Once a page has imported React A (old hash) and then imports React B (new hash), both are already evaluated in the JS VM. A service worker canâ€™t unload modules from a running page. Only a full reload with a single URL for React prevents the split.

Why it â€œworked beforeâ€ but not now

It worked whenever the cached React matched the current build (same hash), or when the SW wasnâ€™t installed yet (or not active in preview). After recent changes, the SW is registering in preview/dev and itâ€™s using cache-first for all static assets, so after a dev restart you end up with old+new chunks side-by-side â†’ two Reacts â†’ useState null.

The stable, non-bandaid fix (minimal and surgical)

Goal: ensure the SW never interferes with dev/preview and never caches JS/CSS even in production. That guarantees only one React runtime ever loads.

1) Only register the SW on production app host

In client/src/main.tsx (or wherever you call navigator.serviceWorker.register), gate it like this:

// main.tsx
const isProd = import.meta.env.PROD;
const host = location.hostname;
const isProdAppHost = host === 'app.theamproject.com'; // prod app only

if (isProd && isProdAppHost && 'serviceWorker' in navigator) {
  navigator.serviceWorker.register('/sw.js');
} else {
  // Ensure no SW is active in dev/preview/marketing subdomain
  if ('serviceWorker' in navigator) {
    navigator.serviceWorker.getRegistrations().then(rs => rs.forEach(r => r.unregister()));
  }
  if ('caches' in window) {
    caches.keys().then(keys => keys.forEach(k => caches.delete(k)));
  }
}


Covers domain + subdomain: SW runs on app.theamproject.com only. It will not register on theamproject.com (marketing) nor Replit preview URLs.

In non-prod contexts we also clean out any lingering SW/caches once so you donâ€™t keep hitting stale chunks in preview.

2) Make the SW skip JS/CSS entirely (even in prod)

In client/public/sw.js, before your cache-first handler, bail out for scripts and styles:

self.addEventListener('fetch', (event) => {
  const req = event.request;

  // Never intercept versioned code assets â€” prevents duplicate React forever.
  const dest = req.destination; // 'script', 'style', 'document', 'image', etc.
  if (dest === 'script' || dest === 'style') {
    return; // Let the network/browser handle it; no cache, no respondWith.
  }

  // ...existing navigation / API / static handlers...
});


If you prefer patterns instead of destination, you can also skip when
/\bchunk-.*\.js/.test(new URL(req.url).pathname) or \.js(\?|$)|\.css(\?|$).

Keep your existing navigation/API caching; just donâ€™t ever cache the code bundles.

3) One-time reset after you change the above

Do this once in any open preview/browser tab (you already have the snippet):

(async () => {
  const regs = await navigator.serviceWorker.getRegistrations();
  for (const r of regs) await r.unregister();
  const keys = await caches.keys();
  for (const k of keys) await caches.delete(k);
  location.reload(true);
})();


After that:

In Replit preview/dev you should not see â€œPWA Service Worker registeredâ€.

The React version log will show a single runtime, and the invalid-hook/useState error will disappear across restarts.

On app.theamproject.com (prod), the SW will run but wonâ€™t cache JS/CSS, so new deploys wonâ€™t ever clash with an old React.

Why this is the â€œreal fixâ€

It removes the condition that creates two Reacts (SW caching code) instead of trying to â€œclear caches fasterâ€.

It respects your architecture (marketing domain vs app subdomain) and avoids surprises in preview/dev.

Itâ€™s future-proof: even with frequent redeploys and changing chunk hashes, no code is cached, so you canâ€™t end up with dual runtimes.

If you want, I can also give you a tiny guard in the SW to skipWaiting() + clients.claim() so prod users see fresh HTML immediately, but the key stability piece is â€œdonâ€™t cache JS/CSSâ€ + â€œdonâ€™t register SW outside prod app host.â€