Here’s the surgical patch set that stops the crash, stabilizes auth-in-PWA, and quiets the SW noise — without touching your Splash component (we’ll use it, not edit it).

0) Non-negotiables

Do NOT modify Splash (file, markup, styles, animations remain intact).

No global PWA overhaul; only what’s needed to stop the crash and auth race.

1) Single React instance (kills the useState null crash)

That console “Invalid hook call” + PWAProvider -> useState means there are two Reacts.

Do this:

In the project root:

npm ls react react-dom


You must see one version of each. If not:

In package.json (root), pin and force a single version:

{
  "dependencies": {
    "react": "18.3.1",
    "react-dom": "18.3.1"
  },
  "overrides": {
    "react": "18.3.1",
    "react-dom": "18.3.1"
  }
}


(If you use pnpm/yarn, use pnpm.overrides / resolutions accordingly.)

In any local/linked packages (e.g., your chat module), move these to peerDependencies:

"peerDependencies": {
  "react": ">=18",
  "react-dom": ">=18"
}


and remove them from dependencies.

Clean install:

rm -rf node_modules
npm i


Hard refresh the browser (Cmd+Shift+R / Ctrl+F5).

Optional (only if allowed): keep your current Vite config; no need to edit it. The override + peerDeps fix is sufficient.

2) Don’t call providers or hooks at module scope

Your stack shows PWAProvider on top. That’s fine — if it’s used in JSX, not invoked like a function.

Quick greps (fix any hits):

grep -R "PWAProvider(" client/src | grep -v "<PWAProvider"
grep -R "useState(" client/src | grep -v ".test."
grep -R "useEffect(" client/src | grep -v ".test."


If you see PWAProvider({ ... }), replace with <PWAProvider>…</PWAProvider>.

If any useState/useEffect is outside a component or custom hook, move it inside.

Keep your current use-pwa-detection.tsx — just ensure it’s used inside components, not at top level.

3) Make the auth boot deterministic (using your existing Splash)

We’ll add a tiny AuthGate wrapper that decides “authed vs guest” before rendering anything, but it uses your Splash unmodified.

Create client/src/auth/AuthGate.tsx:

import React, { useEffect, useState } from 'react';
import Splash from '@/pages/Splash';
import AuthPage from '@/pages/Auth';
import { useAuth } from '@/hooks/use-auth';

type Status = 'checking' | 'authed' | 'guest';

export default function AuthGate({ children }: { children: React.ReactNode }) {
  const [status, setStatus] = useState<Status>('checking');
  const { user, setAccessToken } = useAuth();

  useEffect(() => {
    let cancelled = false;
    (async () => {
      if (user) { if (!cancelled) setStatus('authed'); return; }

      try {
        const me = await fetch('/api/auth/me', { credentials: 'include' });
        if (!cancelled && me.ok) { setStatus('authed'); return; }
      } catch {}

      try {
        const r = await fetch('/api/auth/refresh', { method: 'POST', credentials: 'include' });
        if (!cancelled && r.ok) {
          try { const j = await r.json(); setAccessToken?.(j?.accessToken ?? null); } catch {}
          setStatus('authed'); return;
        }
      } catch {}

      if (!cancelled) setStatus('guest');
    })();
    return () => { cancelled = true; };
  }, [user, setAccessToken]);

  if (status === 'checking') return <Splash />;     // ← YOUR Splash, untouched
  return status === 'authed' ? <>{children}</> : <AuthPage />;
}


Use it only on authed sections (no other routing changes needed):

// App.tsx
import AuthGate from '@/auth/AuthGate';

<Route path="/app">
  {() => (
    <AuthGate>
      <Dashboard />
    </AuthGate>
  )}
</Route>


This removes the splash/auth race and redirect loops. Splash renders exactly as you built it until auth is known.

4) Keep your PWA behavior, fix the env check ONLY

Leave your PWA detection code as-is. Just fix the env usage that controlled the apex→app redirect:

// App.tsx (once at the top)
const isProd = import.meta.env.MODE === 'production';

// where you had:
if (process.env.NODE_ENV === 'production' && !onAppSubdomain && !shouldUsePWA) {
// change to:
if (isProd && !onAppSubdomain && !shouldUsePWA) {
  window.location.assign('https://app.theamproject.com/auth');
  return <div>Redirecting…</div>;
}


No other PWA edits. Your detection stays; we just make the check Vite-safe.

5) Quiet the Service Worker (stop the console storm)

You’ve got dozens of SW fetch/sync errors (InvalidAccessError, repeated Failed to fetch). If you don’t need Background Sync for launch, disable it temporarily to shrink the blast radius — without changing install/caching or your Splash.

In the page script (where you register sync):

// wrap in feature checks AND comment out if not needed for v1
if ('serviceWorker' in navigator && 'SyncManager' in window) {
  try {
    const reg = await navigator.serviceWorker.ready;
    // Temporarily disabled for launch:
    // await reg.sync.register('sync-queued');
  } catch {}
}


In sw.js sync listener, neutralize:

self.addEventListener('sync', (event) => {
  if (event.tag !== 'sync-queued') return;
  // Temporarily no-op: we won't process queued posts for launch
  event.waitUntil(Promise.resolve());
});


Fetch handler guard (avoid spamming errors when offline):

self.addEventListener('fetch', (event) => {
  event.respondWith((async () => {
    try {
      return await fetch(event.request);
    } catch {
      const cached = await caches.match(event.request);
      if (cached) return cached;
      // Optional: return a small fallback for HTML navigations
      if (event.request.mode === 'navigate') {
        return caches.match('/offline.html') || new Response('', { status: 503 });
      }
      return new Response('', { status: 504 });
    }
  })());
});


This stops the flood without touching your Splash or install flow.

6) Fix the WebSocket URL builder (no wss://localhost:undefined)

That log (Failed to construct 'WebSocket'… 'wss://localhost:undefined') is a bad env fallback in your WS setup.

Patch the builder:

function wsURL(token: string) {
  const proto = location.protocol === 'https:' ? 'wss:' : 'ws:';
  const host = location.host; // correct host:port for current env
  return `${proto}//${host}/?token=${encodeURIComponent(token)}`;
}


Use this instead of any localhost:${PORT} logic in the client. Gate any dev-only WS with import.meta.env.MODE.

7) Minimal auth token hygiene (one line, stops desync)

In UnifiedAMChatContext.tsx, stop reading localStorage directly:

// before: const authToken = token || localStorage.getItem('auth_token');
import { useAuth } from '@/hooks/use-auth';
const { accessToken } = useAuth();
if (accessToken) headers['Authorization'] = `Bearer ${accessToken}`;


(Everything else in your auth stays as-is; this just prevents rogue 401 cascades.)

Smoke checklist (5 quick passes)

App boots; no ErrorBoundary.

On apex (non-PWA), /auth still redirects to https://app.theamproject.com/auth in prod.

In PWA, no forced redirects to app.; your Splash displays exactly as before during checking.

After login (or refresh cookie), Splash → authed dashboard; if unauth, Splash → AuthPage.

Console is quiet: no “Invalid hook call,” no WS localhost:undefined, SW errors reduced/eliminated.

If anything above conflicts with a hard repo rule (e.g., you can’t add AuthGate.tsx), say so and I’ll inline the gate logic directly into your existing route without creating a new file. Either way, Splash stays untouched.